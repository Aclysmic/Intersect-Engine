//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.IO;
namespace IntersectServer
{
    public class PacketHandler
    {
        public PacketHandler()
        {

        }

        public void HandlePacket(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            long packetHeader = bf.ReadLong();
            packet = bf.ReadBytes(bf.Length());
            bf.Dispose();

            switch (packetHeader)
            {
                case 0:
                    HandlePing(client);
                    break;

                case 1:
                    HandleLogin(client, packet);
                    break;

                case 2:
                    HandleNeedMap(client, packet);
                    break;

                case 3:
                    HandlePlayerMove(client, packet);
                    break;

                case 4:
                    HandlePlayerMsg(client, packet);
                    break;
                case 5:
                    HandleEditorLogin(client, packet);
                    break;
                case 6:
                    HandleTilesets(client, packet);
                    break;
                case 7:
                    HandleMap(client, packet);
                    break;
                case 8:
                    HandleCreateMap(client, packet);
                    break;
                case 9:
                    HandleEnterMap(client, packet);
                    break;
                case 10:
                    HandleTryAttack(client, packet);
                    break;
                case 11:
                    HandleDir(client, packet);
                    break;
                case 12:
                    HandleEnterGame(client, packet);
                    break;
                case 13:
                    HandleActivateEvent(client, packet);
                    break;
                case 14:
                    HandleEventResponse(client, packet);
                    break;
                case 15:
                    HandleCreateAccount(client, packet);
                    break;
                case 16:
                    HandleItemEditor(client);
                    break;
                case 17:
                    HandleItemData(client, packet);
                    break;
            }

        }

        private void HandlePing(Client client)
        {
            client.connectionTimeout = -1;
            client.pingTime = Environment.TickCount + 10000;
        }

        private void HandleLogin(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            int index = client.entityIndex;
            string username = bf.ReadString();
            string password = bf.ReadString();
            if (Database.accountExists(username))
            {
                if (Database.CheckPassword(username, password))
                {
                    GlobalVariables.entities[index] = new Player(index, client);
                    GlobalVariables.entities[index].myName = username;
                    Console.WriteLine(GlobalVariables.entities[index].myName + " logged in.");
                    client.id = Database.GetUserID(username);
                    Database.LoadPlayer(client);
                    PacketSender.SendJoinGame(client);
                }
                else
                {
                    PacketSender.SendLoginError(client, "Username or password incorrect.");
                }
            }
            else
            {
                PacketSender.SendLoginError(client, "Username or password incorrect.");
            }
            bf.Dispose();
        }

        private void HandleNeedMap(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            PacketSender.SendMap(client, (int)bf.ReadLong());
        }

        private void HandlePlayerMove(Client client, byte[] packet)
        {
            int index = client.entityIndex;
            int oldMap = GlobalVariables.entities[index].currentMap;
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            GlobalVariables.entities[index].currentMap = bf.ReadInteger();
            if (oldMap != GlobalVariables.entities[index].currentMap)
            {
                GlobalVariables.GameMaps[GlobalVariables.entities[index].currentMap].PlayerEnteredMap();
            }
            GlobalVariables.entities[index].currentX = bf.ReadInteger();
            GlobalVariables.entities[index].currentY = bf.ReadInteger();
            GlobalVariables.entities[index].dir = bf.ReadInteger();
            bf.Dispose();

            //Check if valid before sending the move to everyone.

            PacketSender.SendEntityMove(index, 0, GlobalVariables.entities[index]);
        }

        private void HandlePlayerMsg(Client client, byte[] packet)
        {
            int index = client.entityIndex;
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            string msg = bf.ReadString();
            if (msg == "killme")
            {
                GlobalVariables.entities[client.entityIndex].Die();
            }
            PacketSender.SendGlobalMsg(((Player)GlobalVariables.entities[index]).myName + ": " + msg);
            bf.Dispose();
        }

        private void HandleEditorLogin(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            string usr = bf.ReadString();
            string pass = bf.ReadString();
            if (usr == "jcsnider" || usr == "kibbelz" && pass == "test")
            {
                client.isEditor = true;
                PacketSender.SendJoinGame(client);
                PacketSender.SendGameData(client);
                PacketSender.SendTilesets(client);
                PacketSender.SendMapList(client);
            }
        }

        private void HandleTilesets(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            long tilesetCount;
            bf.WriteBytes(packet);
            tilesetCount = bf.ReadLong();
            if (tilesetCount > 0)
            {
                GlobalVariables.tilesets = new string[tilesetCount];
                for (int i = 0; i < tilesetCount; i++)
                {
                    GlobalVariables.tilesets[i] = bf.ReadString();
                }
                File.WriteAllLines("Resources/Tilesets.dat", GlobalVariables.tilesets);

                //Send the updated tilesets to all clients.
                for (int i = 0; i < GlobalVariables.clients.Count; i++)
                {
                    if (i != client.clientIndex)
                    {
                        if (GlobalVariables.clients[i] != null)
                        {
                            if (GlobalVariables.clients[i].isConnected)
                            {
                                PacketSender.SendTilesets(GlobalVariables.clients[i]);
                            }
                        }
                    }
                }
            }
        }

        private void HandleMap(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            long mapLength;
            long mapNum;
            bf.WriteBytes(packet);
            mapNum = bf.ReadLong();
            mapLength = bf.ReadLong();
            GlobalVariables.GameMaps[mapNum].Load(bf.ReadBytes((int)mapLength));
            GlobalVariables.GameMaps[mapNum].Save();
            for (int i = 0; i < GlobalVariables.clients.Count; i++)
            {
                if (GlobalVariables.clients[i] != null)
                {
                    if (GlobalVariables.clients[i].isEditor)
                    {
                        PacketSender.SendMapList(GlobalVariables.clients[i]);
                    }
                }
            }
                bf.Dispose();
        }

        private void HandleCreateMap(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            int location, relativeMap;
            int newMap = -1;
            Map tmpMap = new Map(-1);
            bf.WriteBytes(packet);
            location = (int)bf.ReadLong();
            if (location == -1)
            {
                newMap = Database.AddMap();
                tmpMap = GlobalVariables.GameMaps[newMap];
                tmpMap.Save();
                Database.GenerateMapGrids();
                PacketSender.SendMap(client, newMap);
                PacketSender.SendEnterMap(client, newMap);
            }
            else
            {
                relativeMap = (int)bf.ReadLong();
                switch (location)
                {
                    case 0:
                        if (GlobalVariables.GameMaps[relativeMap].up == -1)
                        {
                            newMap = Database.AddMap();
                            tmpMap = GlobalVariables.GameMaps[newMap];
                            tmpMap.mapGrid = GlobalVariables.GameMaps[relativeMap].mapGrid;
                            tmpMap.mapGridX = GlobalVariables.GameMaps[relativeMap].mapGridX;
                            tmpMap.mapGridY = GlobalVariables.GameMaps[relativeMap].mapGridY - 1;
                            GlobalVariables.GameMaps[relativeMap].up = newMap;

                        }
                        break;

                    case 1:
                        if (GlobalVariables.GameMaps[relativeMap].down == -1)
                        {
                            newMap = Database.AddMap();
                            tmpMap = GlobalVariables.GameMaps[newMap];
                            tmpMap.mapGrid = GlobalVariables.GameMaps[relativeMap].mapGrid;
                            tmpMap.mapGridX = GlobalVariables.GameMaps[relativeMap].mapGridX;
                            tmpMap.mapGridY = GlobalVariables.GameMaps[relativeMap].mapGridY + 1;
                            GlobalVariables.GameMaps[relativeMap].down = newMap;
                        }
                        break;

                    case 2:
                        if (GlobalVariables.GameMaps[relativeMap].left == -1)
                        {
                            newMap = Database.AddMap();
                            tmpMap = GlobalVariables.GameMaps[newMap];
                            tmpMap.mapGrid = GlobalVariables.GameMaps[relativeMap].mapGrid;
                            tmpMap.mapGridX = GlobalVariables.GameMaps[relativeMap].mapGridX - 1;
                            tmpMap.mapGridY = GlobalVariables.GameMaps[relativeMap].mapGridY;
                            GlobalVariables.GameMaps[relativeMap].left = newMap;
                        }
                        break;

                    case 3:
                        if (GlobalVariables.GameMaps[relativeMap].right == -1)
                        {
                            newMap = Database.AddMap();
                            tmpMap = GlobalVariables.GameMaps[newMap];
                            tmpMap.mapGrid = GlobalVariables.GameMaps[relativeMap].mapGrid;
                            tmpMap.mapGridX = GlobalVariables.GameMaps[relativeMap].mapGridX + 1;
                            tmpMap.mapGridY = GlobalVariables.GameMaps[relativeMap].mapGridY;
                            GlobalVariables.GameMaps[relativeMap].right = newMap;
                        }
                        break;

                }

                if (newMap > -1)
                {
                    GlobalVariables.GameMaps[relativeMap].Save();
                    if (tmpMap.mapGridY - 1 >= 0)
                    {
                        tmpMap.up = Database.mapGrids[tmpMap.mapGrid].myGrid[tmpMap.mapGridX, tmpMap.mapGridY - 1];
                    }
                    if (tmpMap.mapGridY + 1 <= Database.mapGrids[tmpMap.mapGrid].height)
                    {
                        tmpMap.down = Database.mapGrids[tmpMap.mapGrid].myGrid[tmpMap.mapGridX, tmpMap.mapGridY + 1];
                    }

                    if (tmpMap.mapGridX - 1 >= 0) { tmpMap.left = Database.mapGrids[tmpMap.mapGrid].myGrid[tmpMap.mapGridX - 1, tmpMap.mapGridY]; }

                    if (tmpMap.mapGridX + 1 <= Database.mapGrids[tmpMap.mapGrid].width)
                    {
                        tmpMap.right = Database.mapGrids[tmpMap.mapGrid].myGrid[tmpMap.mapGridX + 1, tmpMap.mapGridY];
                    }

                    tmpMap.Save();
                    Database.GenerateMapGrids();
                    PacketSender.SendMap(client, newMap);
                    PacketSender.SendEnterMap(client, newMap);
                }
            }
            bf.Dispose();
        }

        private void HandleEnterMap(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            //TODO See if the player is close enough to be switching chunks.
            PacketSender.SendEnterMap(client, (int)bf.ReadLong());
            bf.Dispose();
        }

        private void HandleTryAttack(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            GlobalVariables.entities[client.entityIndex].TryAttack((int)bf.ReadLong());
            bf.Dispose();
        }

        private void HandleDir(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            GlobalVariables.entities[client.entityIndex].ChangeDir((int)bf.ReadLong());
            bf.Dispose();
        }

        private void HandleEnterGame(Client client, byte[] packet)
        {
            int index = client.entityIndex;
            ((Player)GlobalVariables.entities[client.entityIndex]).inGame = true;
            PacketSender.SendGameData(client);
            PacketSender.SendGameTime(client);
            PacketSender.SendPlayerMsg(client, "Welcome to the Intersect game server.");
            PacketSender.SendGlobalMsg(GlobalVariables.entities[index].myName + " has joined the Intersect engine");
            PacketSender.SendTilesets(client);
            for (int i = 0; i < GlobalVariables.entities.Count; i++)
            {
                if (GlobalVariables.entities[i] != null)
                {
                    PacketSender.SendEntityData(client, i, 0, GlobalVariables.entities[i]);
                }
            }
            for (int i = 0; i < GlobalVariables.clients.Count; i++)
            {
                if (i != client.clientIndex)
                {
                    if (GlobalVariables.clients[i] != null)
                    {
                        if (GlobalVariables.clients[i].isConnected)
                        {
                            if (!GlobalVariables.clients[i].isEditor)
                            {
                                PacketSender.SendEntityData(GlobalVariables.clients[i], client.entityIndex,0,GlobalVariables.entities[client.entityIndex]);
                            }
                        }
                    }
                }
            }
            GlobalVariables.entities[index].Warp(GlobalVariables.entities[index].currentMap, GlobalVariables.entities[index].currentX, GlobalVariables.entities[index].currentY, GlobalVariables.entities[index].dir);
            
        }

        private void HandleActivateEvent(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            ((Player)(GlobalVariables.entities[client.entityIndex])).TryActivateEvent(bf.ReadInteger());
            bf.Dispose();
        }

        private void HandleEventResponse(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            ((Player)(GlobalVariables.entities[client.entityIndex])).RespondToEvent(bf.ReadInteger(), bf.ReadInteger());
            bf.Dispose();
        }

        private void HandleCreateAccount(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            string username = bf.ReadString();
            string password = bf.ReadString();
            string email = bf.ReadString();
            int index = client.entityIndex;
            if (Database.accountExists(username))
            {
                PacketSender.SendLoginError(client, "Account already exists!");
            }
            else
            {
                if (Database.emailInUse(email))
                {
                    PacketSender.SendLoginError(client, "An account with this email address already exists.");
                }
                else
                {
                    Database.CreateAccount(username, password, email);
                    client.id = Database.GetUserID(username);
                    GlobalVariables.entities[index].myName = username;
                    Console.WriteLine(GlobalVariables.entities[index].myName + " logged in.");
                    GlobalVariables.entities[index].mySprite = "5";
                    GlobalVariables.entities[index].currentMap = Constants.SPAWN_MAP;
                    GlobalVariables.entities[index].currentX = Constants.SPAWN_X;
                    GlobalVariables.entities[index].currentY = Constants.SPAWN_Y;
                    Database.SavePlayer(client);
                    PacketSender.SendJoinGame(client);
                }
            }
            bf.Dispose();
        }

        private void HandleItemData(Client client, byte[] packet)
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteBytes(packet);
            long itemNum = bf.ReadLong();
            GlobalVariables.GameItems[itemNum].LoadItem(bf);
            GlobalVariables.GameItems[itemNum].Save((int)itemNum);
            bf.Dispose();
        }

        private void HandleItemEditor(Client client)
        {
            for (int i = 0; i < Constants.MAX_ITEMS; i++)
            {
                PacketSender.SendItem(client, i);
            }
            PacketSender.SendItemEditor(client);
        }
    }
}

