//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Net.Sockets;

namespace Intersect_Server.Classes
{
	public class Client
	{

        //Game Incorperation Variables
		public int ClientIndex;
		public int EntityIndex;
        public Player Entity;

        //Ping Values
        public long ConnectionTimeout;
        public long TimeoutLength = 10;
		public long PingTime = 0;

        //Client Properties
		public bool IsEditor;
        public int Power = 0;

        //Database ID
        public int Id = -1;

        //Network Variables
        private byte[] readBuff = new byte[1];
        private long connectTime;
        private TcpClient mySocket;
        private NetworkStream myStream;
        private PacketHandler packetHandler = new PacketHandler();
        private List<byte> myBuffer = new List<byte>();
        public bool isConnected;


        public Client(int myIndex, int entIndex, TcpClient  socket)
		{
            mySocket = socket;
            mySocket.SendBufferSize = 4096;
            mySocket.ReceiveBufferSize = 4096;
            myStream = mySocket.GetStream();
            readBuff = new byte[mySocket.ReceiveBufferSize];
            connectTime = Environment.TickCount;
            myStream.BeginRead(readBuff, 0, mySocket.ReceiveBufferSize, OnReceiveData, connectTime);
			ClientIndex = myIndex;
			EntityIndex = entIndex;
            Entity = (Player)Globals.Entities[EntityIndex];
			PacketSender.SendPing (this);
			isConnected = true;
			ConnectionTimeout = -1;

		}

        private void OnReceiveData(IAsyncResult ar)
        {
            ByteBuffer buff;
            int packetLen;
            var newBytes = new byte[1];
            if ((long)ar.AsyncState != connectTime) { return; }
            try
            {
                var readbytes = myStream.EndRead(ar);
                if (readbytes <= 0) { Console.WriteLine("No bytes read, disconnecting."); HandleDisconnect(); return; }
                newBytes = new byte[readbytes];
                Buffer.BlockCopy(readBuff, 0, newBytes, 0, readbytes);
                myBuffer.AddRange(newBytes);
                if (myBuffer.Count >= 4)
                {
                    buff = new ByteBuffer();
                    buff.WriteBytes(myBuffer.ToArray());
                    while (buff.Length() >= 4)
                    {
                        packetLen = buff.ReadInteger(false);
                        if (packetLen == 0)
                        {
                            break;
                        }
                        if (buff.Length() >= packetLen + 4)
                        {
                            buff.ReadInteger();
                            packetHandler.HandlePacket(this, buff.ReadBytes(packetLen));
                        }
                        else
                        {
                            break;
                        }
                    }
                    myBuffer.Clear();
                    if (buff.Length() > 0)
                    {
                        myBuffer.AddRange(buff.ReadBytes(buff.Length()));
                    }
                }
                readBuff = new byte[mySocket.ReceiveBufferSize];
                myStream.BeginRead(readBuff, 0, mySocket.ReceiveBufferSize, OnReceiveData, connectTime);
            }
            catch (Exception)
            {
                Console.WriteLine("Socket end read error.");
                HandleDisconnect(); 
                return;
            }
        }

		public void HandleDisconnect ()
		{
            if (isConnected)
            {
                isConnected = false;
                if (myStream != null) { myStream.Close(); }
                myStream = null;
                if (mySocket != null) { mySocket.Close(); }
                mySocket = null;
                try
                {
                    Console.WriteLine("Client disconnected.");
                    if (EntityIndex > -1 && Globals.Entities[EntityIndex] != null)
                    {
                        Database.SavePlayer(Globals.Clients[ClientIndex]);
                        PacketSender.SendEntityLeave(EntityIndex,0,Globals.Entities[EntityIndex].CurrentMap);
                        if (Globals.Entities[EntityIndex] == null) { return; }
                        PacketSender.SendGlobalMsg(Globals.Entities[EntityIndex].MyName + " has left the Intersect engine");
                        Globals.Clients[ClientIndex] = null;
                        Globals.Entities[EntityIndex] = null;
                        Entity = null;

                    }
                }
                catch (Exception) { }
            }
			isConnected = false;
		}

		public void Update (PacketHandler packetHandler)
		{
			int readAmt;

			var tempBuff = new byte[4096];

			do {
				try {
					if (IsConnected(mySocket)) {
						if (ConnectionTimeout > -1 && ConnectionTimeout < Environment.TickCount) {
							//Disconnect
							HandleDisconnect ();
							return;
						} else {
							if (PingTime < Environment.TickCount) {
								PacketSender.SendPing (this);
							}
						}
						readAmt = myStream.Read (tempBuff, 0, 4096);
						if (readAmt > 0) {
							for (var i = 0; i < readAmt; i++) {
								myBuffer.Add (tempBuff [i]);
							}
						} else {
							HandleDisconnect ();
							return;
						}
					} else {
						HandleDisconnect ();
						return;
					}
				} catch {
					HandleDisconnect ();
					return;
				}
				
			} while (true);
		}

        public void HandleData(byte[] packet)
        {
            ByteBuffer buff;
			int packetLen;
            myBuffer.AddRange(packet);
            if (myBuffer.Count >= 4)
            {
                buff = new ByteBuffer();
                buff.WriteBytes(myBuffer.ToArray());
                while (buff.Length() >= 4)
                {
                    packetLen = buff.ReadInteger(false);
                    if (packetLen == 0)
                    {
                        break;
                    }
                    if (buff.Length() >= packetLen)
                    {
                        buff.ReadInteger();
                        packetHandler.HandlePacket(this, buff.ReadBytes(packetLen));
                    }
                    else
                    {
                        break;
                    }
                }
                myBuffer.Clear();
                if (buff.Length() > 0)
                {
                    myBuffer.AddRange(buff.ReadBytes(buff.Length()));
                }
            }
        }

		private void HandlePacket (byte[] packet)
		{
			var buff = new ByteBuffer ();
			buff.WriteBytes (packet);
			var tempStr = buff.ReadString ();
			Console.WriteLine (tempStr);
			SendPacket (packet);
			buff.Dispose ();
		}

		public void SendPacket (byte[] packet)
		{
		    var buff = new ByteBuffer ();
			try {
				if (isConnected) {
					buff.WriteInteger (packet.Length);
					buff.WriteBytes (packet);
                    myStream.Write(buff.ToArray(), 0, buff.Count());
				}
			} catch (Exception ex) {
                Console.WriteLine("Send exception, disconnecting.");
                Console.WriteLine(ex.InnerException);
                Console.WriteLine(ex.ToString());
                HandleDisconnect();
                return;
			}
		}

		public static bool IsConnected (TcpClient socket)
		{
            return socket.Connected;
		}
	}
}

