//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18408
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

namespace IntersectServer
{
    public class Map
    {
        private const int layerCount = 5;
        public string myName = "New Map";
        public int up = -1;
        public int down = -1;
        public int left = -1;
        public int right = -1;
        private string BGM = "";
        private TileArray[] Layers = new TileArray[Constants.LAYER_COUNT];
        public int myMapNum = 0;
        public int deleted = 0;
        public byte[] mapGameData;
        public byte[] mapData;
        public int[,] blocked = new int[Constants.MAP_WIDTH, Constants.MAP_HEIGHT];
        public int mapGrid;
        public int mapGridX;
        public int mapGridY;
        public bool active;
        public int revision;
        public List<int> surroundingMaps = new List<int>();
        public List<Event> Events = new List<Event>();
        public List<Light> Lights = new List<Light>();
        public bool isIndoors;
        public Map(int mapNum)
        {
            if (mapNum == -1)
            {
                return;
            }
            myMapNum = mapNum;
            for (int i = 0; i < Constants.LAYER_COUNT; i++)
            {
                Layers[i] = new TileArray();
                for (int x = 0; x < Constants.MAP_WIDTH; x++)
                {
                    for (int y = 0; y < Constants.MAP_HEIGHT; y++)
                    {
                        Layers[i].Tiles[x, y] = new Tile();
                    }
                }
            }
        }

        public void Save()
        {
            ByteBuffer bf = new ByteBuffer();
            bf.WriteString(myName);
            bf.WriteInteger(up);
            bf.WriteInteger(down);
            bf.WriteInteger(left);
            bf.WriteInteger(right);
            bf.WriteString(BGM);
            bf.WriteInteger(Convert.ToInt32(isIndoors));
            for (int i = 0; i < Constants.LAYER_COUNT; i++)
            {
                for (int x = 0; x < Constants.MAP_WIDTH; x++)
                {
                    for (int y = 0; y < Constants.MAP_HEIGHT; y++)
                    {
                        bf.WriteInteger(Layers[i].Tiles[x, y].tilesetIndex);
                        bf.WriteInteger(Layers[i].Tiles[x, y].x);
                        bf.WriteInteger(Layers[i].Tiles[x, y].y);
                        bf.WriteByte(Layers[i].Tiles[x, y].Autotile);
                    }
                }
            }
            for (int x = 0; x < Constants.MAP_WIDTH; x++)
            {
                for (int y = 0; y < Constants.MAP_HEIGHT; y++)
                {
                    bf.WriteInteger(blocked[x, y]);
                }
            }
            bf.WriteInteger(Lights.Count);
            for (int i = 0; i < Lights.Count; i++)
            {
                bf.WriteBytes(Lights[i].LightData());
            }
            bf.WriteInteger(revision);
            bf.WriteLong(deleted);
            mapGameData = bf.ToArray();
            bf.WriteInteger(Events.Count);
            for (int i = 0; i < Events.Count; i++)
            {
                bf.WriteBytes(Events[i].EventData());
            }
            Stream stream = File.Create("Resources/Maps/" + myMapNum + ".map");
            stream.Write(bf.ToArray(), 0, bf.ToArray().Length);
            stream.Close();
            mapData = bf.ToArray();
        }

        public void Load(byte[] packet)
        {
            ByteBuffer bf;
            bf = new ByteBuffer();
            bf.WriteBytes(packet);
            mapData = bf.ToArray();
            myName = bf.ReadString();
            up = bf.ReadInteger();
            down = bf.ReadInteger();
            left = bf.ReadInteger();
            right = bf.ReadInteger();
            BGM = bf.ReadString();
            isIndoors = Convert.ToBoolean(bf.ReadInteger());
            for (int i = 0; i < Constants.LAYER_COUNT; i++)
            {
                for (int x = 0; x < Constants.MAP_WIDTH; x++)
                {
                    for (int y = 0; y < Constants.MAP_HEIGHT; y++)
                    {
                        Layers[i].Tiles[x, y].tilesetIndex = bf.ReadInteger();
                        Layers[i].Tiles[x, y].x = bf.ReadInteger();
                        Layers[i].Tiles[x, y].y = bf.ReadInteger();
                        Layers[i].Tiles[x, y].Autotile = bf.ReadByte();
                    }
                }
            }
            for (int x = 0; x < Constants.MAP_WIDTH; x++)
            {
                for (int y = 0; y < Constants.MAP_HEIGHT; y++)
                {
                    blocked[x, y] = bf.ReadInteger();
                }
            }
            int lCount = bf.ReadInteger();
            Lights.Clear();
            for (int i = 0; i < lCount; i++)
            {
                Lights.Add(new Light(bf));
            }
            revision = bf.ReadInteger();
            deleted = (int)bf.ReadLong();
            mapGameData = packet.Skip(0).Take(bf.Pos()).ToArray();
            Events.Clear();
            int eCount = bf.ReadInteger();
            for (int i = 0; i < eCount; i++)
            {
                Events.Add(new Event(bf));
            }
            Save();
        }

        public void Update()
        {
            if (CheckActive() == false) { return; }
            for (int i = 0; i < GlobalVariables.entities.Count; i++)
            {
                if (GlobalVariables.entities[i] != null)
                {
                    if (GlobalVariables.entities[i].GetType() == typeof(NPC))
                    {
                        if (GlobalVariables.entities[i].currentMap == myMapNum)
                        {
                            ((NPC)GlobalVariables.entities[i]).Update();
                        }
                    }
                    else if (GlobalVariables.entities[i].GetType() == typeof(Player))
                    {
                        if (GlobalVariables.entities[i].currentMap == myMapNum)
                        {
                            ((Player)GlobalVariables.entities[i]).Update();
                        }

                    }
                }
            }
        }

        private bool CheckActive()
        {
            if (PlayersOnMap(myMapNum))
            {
                return true;
            }
            else
            {
                if (surroundingMaps.Count > 0)
                {
                    for (int i = 0; i < surroundingMaps.Count; i++)
                    {
                        if (PlayersOnMap(surroundingMaps[i]))
                        {
                            return true;
                        }
                    }
                }
            }
            active = false;
            return false;
        }

        private bool PlayersOnMap(int mapNum)
        {
            if (GlobalVariables.clients.Count > 0)
            {
                for (int i = 0; i < GlobalVariables.clients.Count; i++)
                {
                    if (GlobalVariables.clients[i] != null)
                    {
                        if (GlobalVariables.clients[i].entityIndex > -1)
                        {
                            if (((Player)GlobalVariables.entities[GlobalVariables.clients[i].entityIndex]) != null)
                            {
                                if (((Player)GlobalVariables.entities[GlobalVariables.clients[i].entityIndex]).inGame)
                                {
                                    if (GlobalVariables.entities[GlobalVariables.clients[i].entityIndex].currentMap == mapNum)
                                    {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        public void PlayerEnteredMap()
        {
            active = true;
            if (surroundingMaps.Count > 0)
            {
                for (int i = 0; i < surroundingMaps.Count; i++)
                {
                    GlobalVariables.GameMaps[surroundingMaps[i]].active = true;
                }
            }

        }

    }

    class TileArray
    {
        public Tile[,] Tiles = new Tile[Constants.MAP_WIDTH, Constants.MAP_HEIGHT];
    }

    class Tile
    {
        public int tilesetIndex = -1;
        public int x;
        public int y;
        public byte Autotile;
    }

    public class Light
    {
        public int offsetX = 0;
        public int offsetY = 0;
        public int tileX;
        public int tileY;
        public double intensity = 1;
        public int range = 20;
        public Light(ByteBuffer myBuffer)
        {
            offsetX = myBuffer.ReadInteger();
            offsetY = myBuffer.ReadInteger();
            tileX = myBuffer.ReadInteger();
            tileY = myBuffer.ReadInteger();
            intensity = myBuffer.ReadDouble();
            range = myBuffer.ReadInteger();
        }
        public byte[] LightData()
        {
            ByteBuffer myBuffer = new ByteBuffer();
            myBuffer.WriteInteger(offsetX);
            myBuffer.WriteInteger(offsetY);
            myBuffer.WriteInteger(tileX);
            myBuffer.WriteInteger(tileY);
            myBuffer.WriteDouble(intensity);
            myBuffer.WriteInteger(range);
            return myBuffer.ToArray();
        }
    }
}


